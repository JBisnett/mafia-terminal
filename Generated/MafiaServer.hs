{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.9.3)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Generated.MafiaServer where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T


import Generated.Mafia_Types
import qualified Generated.MafiaServer_Iface as Iface
-- HELPER FUNCTIONS AND STRUCTURES --

data Ping_args = Ping_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Ping_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary Ping_args where 
  arbitrary = QC.elements [Ping_args]
from_Ping_args :: Ping_args -> T.ThriftVal
from_Ping_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_Ping_args :: (T.Protocol p, T.Transport t) => p t -> Ping_args -> P.IO ()
write_Ping_args oprot record = T.writeVal oprot $ from_Ping_args record
encode_Ping_args :: (T.Protocol p, T.Transport t) => p t -> Ping_args -> LBS.ByteString
encode_Ping_args oprot record = T.serializeVal oprot $ from_Ping_args record
to_Ping_args :: T.ThriftVal -> Ping_args
to_Ping_args (T.TStruct fields) = Ping_args{

  }
to_Ping_args _ = P.error "not a struct"
read_Ping_args :: (T.Transport t, T.Protocol p) => p t -> P.IO Ping_args
read_Ping_args iprot = to_Ping_args <$> T.readVal iprot (T.T_STRUCT typemap_Ping_args)
decode_Ping_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Ping_args
decode_Ping_args iprot bs = to_Ping_args $ T.deserializeVal iprot (T.T_STRUCT typemap_Ping_args) bs
typemap_Ping_args :: T.TypeMap
typemap_Ping_args = Map.fromList []
default_Ping_args :: Ping_args
default_Ping_args = Ping_args{
}
data Ping_result = Ping_result deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Ping_result where
  hashWithSalt salt record = salt  
instance QC.Arbitrary Ping_result where 
  arbitrary = QC.elements [Ping_result]
from_Ping_result :: Ping_result -> T.ThriftVal
from_Ping_result record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_Ping_result :: (T.Protocol p, T.Transport t) => p t -> Ping_result -> P.IO ()
write_Ping_result oprot record = T.writeVal oprot $ from_Ping_result record
encode_Ping_result :: (T.Protocol p, T.Transport t) => p t -> Ping_result -> LBS.ByteString
encode_Ping_result oprot record = T.serializeVal oprot $ from_Ping_result record
to_Ping_result :: T.ThriftVal -> Ping_result
to_Ping_result (T.TStruct fields) = Ping_result{

  }
to_Ping_result _ = P.error "not a struct"
read_Ping_result :: (T.Transport t, T.Protocol p) => p t -> P.IO Ping_result
read_Ping_result iprot = to_Ping_result <$> T.readVal iprot (T.T_STRUCT typemap_Ping_result)
decode_Ping_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Ping_result
decode_Ping_result iprot bs = to_Ping_result $ T.deserializeVal iprot (T.T_STRUCT typemap_Ping_result) bs
typemap_Ping_result :: T.TypeMap
typemap_Ping_result = Map.fromList []
default_Ping_result :: Ping_result
default_Ping_result = Ping_result{
}
data Join_game_args = Join_game_args  { join_game_args_name :: LT.Text
  , join_game_args_host :: LT.Text
  , join_game_args_port :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Join_game_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` join_game_args_name record   `H.hashWithSalt` join_game_args_host record   `H.hashWithSalt` join_game_args_port record  
instance QC.Arbitrary Join_game_args where 
  arbitrary = M.liftM Join_game_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Join_game_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Join_game_args{join_game_args_name = join_game_args_name obj} then P.Nothing else P.Just $ default_Join_game_args{join_game_args_name = join_game_args_name obj}
    , if obj == default_Join_game_args{join_game_args_host = join_game_args_host obj} then P.Nothing else P.Just $ default_Join_game_args{join_game_args_host = join_game_args_host obj}
    , if obj == default_Join_game_args{join_game_args_port = join_game_args_port obj} then P.Nothing else P.Just $ default_Join_game_args{join_game_args_port = join_game_args_port obj}
    ]
from_Join_game_args :: Join_game_args -> T.ThriftVal
from_Join_game_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v12 -> P.Just (1, ("name",T.TString $ E.encodeUtf8 _v12))) $ join_game_args_name record
  , (\_v12 -> P.Just (2, ("host",T.TString $ E.encodeUtf8 _v12))) $ join_game_args_host record
  , (\_v12 -> P.Just (3, ("port",T.TI32 _v12))) $ join_game_args_port record
  ]
write_Join_game_args :: (T.Protocol p, T.Transport t) => p t -> Join_game_args -> P.IO ()
write_Join_game_args oprot record = T.writeVal oprot $ from_Join_game_args record
encode_Join_game_args :: (T.Protocol p, T.Transport t) => p t -> Join_game_args -> LBS.ByteString
encode_Join_game_args oprot record = T.serializeVal oprot $ from_Join_game_args record
to_Join_game_args :: T.ThriftVal -> Join_game_args
to_Join_game_args (T.TStruct fields) = Join_game_args{
  join_game_args_name = P.maybe (join_game_args_name default_Join_game_args) (\(_,_val14) -> (case _val14 of {T.TString _val15 -> E.decodeUtf8 _val15; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  join_game_args_host = P.maybe (join_game_args_host default_Join_game_args) (\(_,_val14) -> (case _val14 of {T.TString _val16 -> E.decodeUtf8 _val16; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  join_game_args_port = P.maybe (join_game_args_port default_Join_game_args) (\(_,_val14) -> (case _val14 of {T.TI32 _val17 -> _val17; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_Join_game_args _ = P.error "not a struct"
read_Join_game_args :: (T.Transport t, T.Protocol p) => p t -> P.IO Join_game_args
read_Join_game_args iprot = to_Join_game_args <$> T.readVal iprot (T.T_STRUCT typemap_Join_game_args)
decode_Join_game_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Join_game_args
decode_Join_game_args iprot bs = to_Join_game_args $ T.deserializeVal iprot (T.T_STRUCT typemap_Join_game_args) bs
typemap_Join_game_args :: T.TypeMap
typemap_Join_game_args = Map.fromList [(1,("name",T.T_STRING)),(2,("host",T.T_STRING)),(3,("port",T.T_I32))]
default_Join_game_args :: Join_game_args
default_Join_game_args = Join_game_args{
  join_game_args_name = "",
  join_game_args_host = "",
  join_game_args_port = 0}
data Join_game_result = Join_game_result  { join_game_result_success :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Join_game_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` join_game_result_success record  
instance QC.Arbitrary Join_game_result where 
  arbitrary = M.liftM Join_game_result (QC.arbitrary)
  shrink obj | obj == default_Join_game_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Join_game_result{join_game_result_success = join_game_result_success obj} then P.Nothing else P.Just $ default_Join_game_result{join_game_result_success = join_game_result_success obj}
    ]
from_Join_game_result :: Join_game_result -> T.ThriftVal
from_Join_game_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v20 -> P.Just (0, ("success",T.TBool _v20))) $ join_game_result_success record
  ]
write_Join_game_result :: (T.Protocol p, T.Transport t) => p t -> Join_game_result -> P.IO ()
write_Join_game_result oprot record = T.writeVal oprot $ from_Join_game_result record
encode_Join_game_result :: (T.Protocol p, T.Transport t) => p t -> Join_game_result -> LBS.ByteString
encode_Join_game_result oprot record = T.serializeVal oprot $ from_Join_game_result record
to_Join_game_result :: T.ThriftVal -> Join_game_result
to_Join_game_result (T.TStruct fields) = Join_game_result{
  join_game_result_success = P.maybe (join_game_result_success default_Join_game_result) (\(_,_val22) -> (case _val22 of {T.TBool _val23 -> _val23; _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_Join_game_result _ = P.error "not a struct"
read_Join_game_result :: (T.Transport t, T.Protocol p) => p t -> P.IO Join_game_result
read_Join_game_result iprot = to_Join_game_result <$> T.readVal iprot (T.T_STRUCT typemap_Join_game_result)
decode_Join_game_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Join_game_result
decode_Join_game_result iprot bs = to_Join_game_result $ T.deserializeVal iprot (T.T_STRUCT typemap_Join_game_result) bs
typemap_Join_game_result :: T.TypeMap
typemap_Join_game_result = Map.fromList [(0,("success",T.T_BOOL))]
default_Join_game_result :: Join_game_result
default_Join_game_result = Join_game_result{
  join_game_result_success = P.False}
data Take_action_args = Take_action_args  { take_action_args_action :: I.Int32
  , take_action_args_target :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Take_action_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` take_action_args_action record   `H.hashWithSalt` take_action_args_target record  
instance QC.Arbitrary Take_action_args where 
  arbitrary = M.liftM Take_action_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Take_action_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Take_action_args{take_action_args_action = take_action_args_action obj} then P.Nothing else P.Just $ default_Take_action_args{take_action_args_action = take_action_args_action obj}
    , if obj == default_Take_action_args{take_action_args_target = take_action_args_target obj} then P.Nothing else P.Just $ default_Take_action_args{take_action_args_target = take_action_args_target obj}
    ]
from_Take_action_args :: Take_action_args -> T.ThriftVal
from_Take_action_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v26 -> P.Just (1, ("action",T.TI32 _v26))) $ take_action_args_action record
  , (\_v26 -> P.Just (2, ("target",T.TString $ E.encodeUtf8 _v26))) $ take_action_args_target record
  ]
write_Take_action_args :: (T.Protocol p, T.Transport t) => p t -> Take_action_args -> P.IO ()
write_Take_action_args oprot record = T.writeVal oprot $ from_Take_action_args record
encode_Take_action_args :: (T.Protocol p, T.Transport t) => p t -> Take_action_args -> LBS.ByteString
encode_Take_action_args oprot record = T.serializeVal oprot $ from_Take_action_args record
to_Take_action_args :: T.ThriftVal -> Take_action_args
to_Take_action_args (T.TStruct fields) = Take_action_args{
  take_action_args_action = P.maybe (take_action_args_action default_Take_action_args) (\(_,_val28) -> (case _val28 of {T.TI32 _val29 -> _val29; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  take_action_args_target = P.maybe (take_action_args_target default_Take_action_args) (\(_,_val28) -> (case _val28 of {T.TString _val30 -> E.decodeUtf8 _val30; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_Take_action_args _ = P.error "not a struct"
read_Take_action_args :: (T.Transport t, T.Protocol p) => p t -> P.IO Take_action_args
read_Take_action_args iprot = to_Take_action_args <$> T.readVal iprot (T.T_STRUCT typemap_Take_action_args)
decode_Take_action_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Take_action_args
decode_Take_action_args iprot bs = to_Take_action_args $ T.deserializeVal iprot (T.T_STRUCT typemap_Take_action_args) bs
typemap_Take_action_args :: T.TypeMap
typemap_Take_action_args = Map.fromList [(1,("action",T.T_I32)),(2,("target",T.T_STRING))]
default_Take_action_args :: Take_action_args
default_Take_action_args = Take_action_args{
  take_action_args_action = 0,
  take_action_args_target = ""}
data Take_action_result = Take_action_result  { take_action_result_success :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Take_action_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` take_action_result_success record  
instance QC.Arbitrary Take_action_result where 
  arbitrary = M.liftM Take_action_result (QC.arbitrary)
  shrink obj | obj == default_Take_action_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Take_action_result{take_action_result_success = take_action_result_success obj} then P.Nothing else P.Just $ default_Take_action_result{take_action_result_success = take_action_result_success obj}
    ]
from_Take_action_result :: Take_action_result -> T.ThriftVal
from_Take_action_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v33 -> P.Just (0, ("success",T.TBool _v33))) $ take_action_result_success record
  ]
write_Take_action_result :: (T.Protocol p, T.Transport t) => p t -> Take_action_result -> P.IO ()
write_Take_action_result oprot record = T.writeVal oprot $ from_Take_action_result record
encode_Take_action_result :: (T.Protocol p, T.Transport t) => p t -> Take_action_result -> LBS.ByteString
encode_Take_action_result oprot record = T.serializeVal oprot $ from_Take_action_result record
to_Take_action_result :: T.ThriftVal -> Take_action_result
to_Take_action_result (T.TStruct fields) = Take_action_result{
  take_action_result_success = P.maybe (take_action_result_success default_Take_action_result) (\(_,_val35) -> (case _val35 of {T.TBool _val36 -> _val36; _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_Take_action_result _ = P.error "not a struct"
read_Take_action_result :: (T.Transport t, T.Protocol p) => p t -> P.IO Take_action_result
read_Take_action_result iprot = to_Take_action_result <$> T.readVal iprot (T.T_STRUCT typemap_Take_action_result)
decode_Take_action_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Take_action_result
decode_Take_action_result iprot bs = to_Take_action_result $ T.deserializeVal iprot (T.T_STRUCT typemap_Take_action_result) bs
typemap_Take_action_result :: T.TypeMap
typemap_Take_action_result = Map.fromList [(0,("success",T.T_BOOL))]
default_Take_action_result :: Take_action_result
default_Take_action_result = Take_action_result{
  take_action_result_success = P.False}
data Public_message_args = Public_message_args  { public_message_args_message :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Public_message_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` public_message_args_message record  
instance QC.Arbitrary Public_message_args where 
  arbitrary = M.liftM Public_message_args (QC.arbitrary)
  shrink obj | obj == default_Public_message_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Public_message_args{public_message_args_message = public_message_args_message obj} then P.Nothing else P.Just $ default_Public_message_args{public_message_args_message = public_message_args_message obj}
    ]
from_Public_message_args :: Public_message_args -> T.ThriftVal
from_Public_message_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v39 -> P.Just (1, ("message",T.TString $ E.encodeUtf8 _v39))) $ public_message_args_message record
  ]
write_Public_message_args :: (T.Protocol p, T.Transport t) => p t -> Public_message_args -> P.IO ()
write_Public_message_args oprot record = T.writeVal oprot $ from_Public_message_args record
encode_Public_message_args :: (T.Protocol p, T.Transport t) => p t -> Public_message_args -> LBS.ByteString
encode_Public_message_args oprot record = T.serializeVal oprot $ from_Public_message_args record
to_Public_message_args :: T.ThriftVal -> Public_message_args
to_Public_message_args (T.TStruct fields) = Public_message_args{
  public_message_args_message = P.maybe (public_message_args_message default_Public_message_args) (\(_,_val41) -> (case _val41 of {T.TString _val42 -> E.decodeUtf8 _val42; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_Public_message_args _ = P.error "not a struct"
read_Public_message_args :: (T.Transport t, T.Protocol p) => p t -> P.IO Public_message_args
read_Public_message_args iprot = to_Public_message_args <$> T.readVal iprot (T.T_STRUCT typemap_Public_message_args)
decode_Public_message_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Public_message_args
decode_Public_message_args iprot bs = to_Public_message_args $ T.deserializeVal iprot (T.T_STRUCT typemap_Public_message_args) bs
typemap_Public_message_args :: T.TypeMap
typemap_Public_message_args = Map.fromList [(1,("message",T.T_STRING))]
default_Public_message_args :: Public_message_args
default_Public_message_args = Public_message_args{
  public_message_args_message = ""}
data Public_message_result = Public_message_result  { public_message_result_success :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Public_message_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` public_message_result_success record  
instance QC.Arbitrary Public_message_result where 
  arbitrary = M.liftM Public_message_result (QC.arbitrary)
  shrink obj | obj == default_Public_message_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Public_message_result{public_message_result_success = public_message_result_success obj} then P.Nothing else P.Just $ default_Public_message_result{public_message_result_success = public_message_result_success obj}
    ]
from_Public_message_result :: Public_message_result -> T.ThriftVal
from_Public_message_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v45 -> P.Just (0, ("success",T.TBool _v45))) $ public_message_result_success record
  ]
write_Public_message_result :: (T.Protocol p, T.Transport t) => p t -> Public_message_result -> P.IO ()
write_Public_message_result oprot record = T.writeVal oprot $ from_Public_message_result record
encode_Public_message_result :: (T.Protocol p, T.Transport t) => p t -> Public_message_result -> LBS.ByteString
encode_Public_message_result oprot record = T.serializeVal oprot $ from_Public_message_result record
to_Public_message_result :: T.ThriftVal -> Public_message_result
to_Public_message_result (T.TStruct fields) = Public_message_result{
  public_message_result_success = P.maybe (public_message_result_success default_Public_message_result) (\(_,_val47) -> (case _val47 of {T.TBool _val48 -> _val48; _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_Public_message_result _ = P.error "not a struct"
read_Public_message_result :: (T.Transport t, T.Protocol p) => p t -> P.IO Public_message_result
read_Public_message_result iprot = to_Public_message_result <$> T.readVal iprot (T.T_STRUCT typemap_Public_message_result)
decode_Public_message_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Public_message_result
decode_Public_message_result iprot bs = to_Public_message_result $ T.deserializeVal iprot (T.T_STRUCT typemap_Public_message_result) bs
typemap_Public_message_result :: T.TypeMap
typemap_Public_message_result = Map.fromList [(0,("success",T.T_BOOL))]
default_Public_message_result :: Public_message_result
default_Public_message_result = Public_message_result{
  public_message_result_success = P.False}
data Group_message_args = Group_message_args  { group_message_args_group_id :: I.Int32
  , group_message_args_message :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Group_message_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` group_message_args_group_id record   `H.hashWithSalt` group_message_args_message record  
instance QC.Arbitrary Group_message_args where 
  arbitrary = M.liftM Group_message_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Group_message_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Group_message_args{group_message_args_group_id = group_message_args_group_id obj} then P.Nothing else P.Just $ default_Group_message_args{group_message_args_group_id = group_message_args_group_id obj}
    , if obj == default_Group_message_args{group_message_args_message = group_message_args_message obj} then P.Nothing else P.Just $ default_Group_message_args{group_message_args_message = group_message_args_message obj}
    ]
from_Group_message_args :: Group_message_args -> T.ThriftVal
from_Group_message_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v51 -> P.Just (1, ("group_id",T.TI32 _v51))) $ group_message_args_group_id record
  , (\_v51 -> P.Just (2, ("message",T.TString $ E.encodeUtf8 _v51))) $ group_message_args_message record
  ]
write_Group_message_args :: (T.Protocol p, T.Transport t) => p t -> Group_message_args -> P.IO ()
write_Group_message_args oprot record = T.writeVal oprot $ from_Group_message_args record
encode_Group_message_args :: (T.Protocol p, T.Transport t) => p t -> Group_message_args -> LBS.ByteString
encode_Group_message_args oprot record = T.serializeVal oprot $ from_Group_message_args record
to_Group_message_args :: T.ThriftVal -> Group_message_args
to_Group_message_args (T.TStruct fields) = Group_message_args{
  group_message_args_group_id = P.maybe (group_message_args_group_id default_Group_message_args) (\(_,_val53) -> (case _val53 of {T.TI32 _val54 -> _val54; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  group_message_args_message = P.maybe (group_message_args_message default_Group_message_args) (\(_,_val53) -> (case _val53 of {T.TString _val55 -> E.decodeUtf8 _val55; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_Group_message_args _ = P.error "not a struct"
read_Group_message_args :: (T.Transport t, T.Protocol p) => p t -> P.IO Group_message_args
read_Group_message_args iprot = to_Group_message_args <$> T.readVal iprot (T.T_STRUCT typemap_Group_message_args)
decode_Group_message_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Group_message_args
decode_Group_message_args iprot bs = to_Group_message_args $ T.deserializeVal iprot (T.T_STRUCT typemap_Group_message_args) bs
typemap_Group_message_args :: T.TypeMap
typemap_Group_message_args = Map.fromList [(1,("group_id",T.T_I32)),(2,("message",T.T_STRING))]
default_Group_message_args :: Group_message_args
default_Group_message_args = Group_message_args{
  group_message_args_group_id = 0,
  group_message_args_message = ""}
data Group_message_result = Group_message_result  { group_message_result_success :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Group_message_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` group_message_result_success record  
instance QC.Arbitrary Group_message_result where 
  arbitrary = M.liftM Group_message_result (QC.arbitrary)
  shrink obj | obj == default_Group_message_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Group_message_result{group_message_result_success = group_message_result_success obj} then P.Nothing else P.Just $ default_Group_message_result{group_message_result_success = group_message_result_success obj}
    ]
from_Group_message_result :: Group_message_result -> T.ThriftVal
from_Group_message_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v58 -> P.Just (0, ("success",T.TBool _v58))) $ group_message_result_success record
  ]
write_Group_message_result :: (T.Protocol p, T.Transport t) => p t -> Group_message_result -> P.IO ()
write_Group_message_result oprot record = T.writeVal oprot $ from_Group_message_result record
encode_Group_message_result :: (T.Protocol p, T.Transport t) => p t -> Group_message_result -> LBS.ByteString
encode_Group_message_result oprot record = T.serializeVal oprot $ from_Group_message_result record
to_Group_message_result :: T.ThriftVal -> Group_message_result
to_Group_message_result (T.TStruct fields) = Group_message_result{
  group_message_result_success = P.maybe (group_message_result_success default_Group_message_result) (\(_,_val60) -> (case _val60 of {T.TBool _val61 -> _val61; _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_Group_message_result _ = P.error "not a struct"
read_Group_message_result :: (T.Transport t, T.Protocol p) => p t -> P.IO Group_message_result
read_Group_message_result iprot = to_Group_message_result <$> T.readVal iprot (T.T_STRUCT typemap_Group_message_result)
decode_Group_message_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Group_message_result
decode_Group_message_result iprot bs = to_Group_message_result $ T.deserializeVal iprot (T.T_STRUCT typemap_Group_message_result) bs
typemap_Group_message_result :: T.TypeMap
typemap_Group_message_result = Map.fromList [(0,("success",T.T_BOOL))]
default_Group_message_result :: Group_message_result
default_Group_message_result = Group_message_result{
  group_message_result_success = P.False}
data Private_message_args = Private_message_args  { private_message_args_player_name :: LT.Text
  , private_message_args_message :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Private_message_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` private_message_args_player_name record   `H.hashWithSalt` private_message_args_message record  
instance QC.Arbitrary Private_message_args where 
  arbitrary = M.liftM Private_message_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Private_message_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Private_message_args{private_message_args_player_name = private_message_args_player_name obj} then P.Nothing else P.Just $ default_Private_message_args{private_message_args_player_name = private_message_args_player_name obj}
    , if obj == default_Private_message_args{private_message_args_message = private_message_args_message obj} then P.Nothing else P.Just $ default_Private_message_args{private_message_args_message = private_message_args_message obj}
    ]
from_Private_message_args :: Private_message_args -> T.ThriftVal
from_Private_message_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v64 -> P.Just (1, ("player_name",T.TString $ E.encodeUtf8 _v64))) $ private_message_args_player_name record
  , (\_v64 -> P.Just (2, ("message",T.TString $ E.encodeUtf8 _v64))) $ private_message_args_message record
  ]
write_Private_message_args :: (T.Protocol p, T.Transport t) => p t -> Private_message_args -> P.IO ()
write_Private_message_args oprot record = T.writeVal oprot $ from_Private_message_args record
encode_Private_message_args :: (T.Protocol p, T.Transport t) => p t -> Private_message_args -> LBS.ByteString
encode_Private_message_args oprot record = T.serializeVal oprot $ from_Private_message_args record
to_Private_message_args :: T.ThriftVal -> Private_message_args
to_Private_message_args (T.TStruct fields) = Private_message_args{
  private_message_args_player_name = P.maybe (private_message_args_player_name default_Private_message_args) (\(_,_val66) -> (case _val66 of {T.TString _val67 -> E.decodeUtf8 _val67; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  private_message_args_message = P.maybe (private_message_args_message default_Private_message_args) (\(_,_val66) -> (case _val66 of {T.TString _val68 -> E.decodeUtf8 _val68; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_Private_message_args _ = P.error "not a struct"
read_Private_message_args :: (T.Transport t, T.Protocol p) => p t -> P.IO Private_message_args
read_Private_message_args iprot = to_Private_message_args <$> T.readVal iprot (T.T_STRUCT typemap_Private_message_args)
decode_Private_message_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Private_message_args
decode_Private_message_args iprot bs = to_Private_message_args $ T.deserializeVal iprot (T.T_STRUCT typemap_Private_message_args) bs
typemap_Private_message_args :: T.TypeMap
typemap_Private_message_args = Map.fromList [(1,("player_name",T.T_STRING)),(2,("message",T.T_STRING))]
default_Private_message_args :: Private_message_args
default_Private_message_args = Private_message_args{
  private_message_args_player_name = "",
  private_message_args_message = ""}
data Private_message_result = Private_message_result  { private_message_result_success :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Private_message_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` private_message_result_success record  
instance QC.Arbitrary Private_message_result where 
  arbitrary = M.liftM Private_message_result (QC.arbitrary)
  shrink obj | obj == default_Private_message_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Private_message_result{private_message_result_success = private_message_result_success obj} then P.Nothing else P.Just $ default_Private_message_result{private_message_result_success = private_message_result_success obj}
    ]
from_Private_message_result :: Private_message_result -> T.ThriftVal
from_Private_message_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v71 -> P.Just (0, ("success",T.TBool _v71))) $ private_message_result_success record
  ]
write_Private_message_result :: (T.Protocol p, T.Transport t) => p t -> Private_message_result -> P.IO ()
write_Private_message_result oprot record = T.writeVal oprot $ from_Private_message_result record
encode_Private_message_result :: (T.Protocol p, T.Transport t) => p t -> Private_message_result -> LBS.ByteString
encode_Private_message_result oprot record = T.serializeVal oprot $ from_Private_message_result record
to_Private_message_result :: T.ThriftVal -> Private_message_result
to_Private_message_result (T.TStruct fields) = Private_message_result{
  private_message_result_success = P.maybe (private_message_result_success default_Private_message_result) (\(_,_val73) -> (case _val73 of {T.TBool _val74 -> _val74; _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_Private_message_result _ = P.error "not a struct"
read_Private_message_result :: (T.Transport t, T.Protocol p) => p t -> P.IO Private_message_result
read_Private_message_result iprot = to_Private_message_result <$> T.readVal iprot (T.T_STRUCT typemap_Private_message_result)
decode_Private_message_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Private_message_result
decode_Private_message_result iprot bs = to_Private_message_result $ T.deserializeVal iprot (T.T_STRUCT typemap_Private_message_result) bs
typemap_Private_message_result :: T.TypeMap
typemap_Private_message_result = Map.fromList [(0,("success",T.T_BOOL))]
default_Private_message_result :: Private_message_result
default_Private_message_result = Private_message_result{
  private_message_result_success = P.False}
process_ping (seqid, iprot, oprot, handler) = do
  args <- read_Ping_args iprot
  (X.catch
    (do
      Iface.ping handler
      let res = default_Ping_result
      T.writeMessageBegin oprot ("ping", T.M_REPLY, seqid)
      write_Ping_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("ping", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_join_game (seqid, iprot, oprot, handler) = do
  args <- read_Join_game_args iprot
  (X.catch
    (do
      val <- Iface.join_game handler (join_game_args_name args) (join_game_args_host args) (join_game_args_port args)
      let res = default_Join_game_result{join_game_result_success = val}
      T.writeMessageBegin oprot ("join_game", T.M_REPLY, seqid)
      write_Join_game_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("join_game", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_take_action (seqid, iprot, oprot, handler) = do
  args <- read_Take_action_args iprot
  (X.catch
    (do
      val <- Iface.take_action handler (take_action_args_action args) (take_action_args_target args)
      let res = default_Take_action_result{take_action_result_success = val}
      T.writeMessageBegin oprot ("take_action", T.M_REPLY, seqid)
      write_Take_action_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("take_action", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_public_message (seqid, iprot, oprot, handler) = do
  args <- read_Public_message_args iprot
  (X.catch
    (do
      val <- Iface.public_message handler (public_message_args_message args)
      let res = default_Public_message_result{public_message_result_success = val}
      T.writeMessageBegin oprot ("public_message", T.M_REPLY, seqid)
      write_Public_message_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("public_message", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_group_message (seqid, iprot, oprot, handler) = do
  args <- read_Group_message_args iprot
  (X.catch
    (do
      val <- Iface.group_message handler (group_message_args_group_id args) (group_message_args_message args)
      let res = default_Group_message_result{group_message_result_success = val}
      T.writeMessageBegin oprot ("group_message", T.M_REPLY, seqid)
      write_Group_message_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("group_message", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_private_message (seqid, iprot, oprot, handler) = do
  args <- read_Private_message_args iprot
  (X.catch
    (do
      val <- Iface.private_message handler (private_message_args_player_name args) (private_message_args_message args)
      let res = default_Private_message_result{private_message_result_success = val}
      T.writeMessageBegin oprot ("private_message", T.M_REPLY, seqid)
      write_Private_message_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("private_message", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
proc_ handler (iprot,oprot) (name,typ,seqid) = case name of
  "ping" -> process_ping (seqid,iprot,oprot,handler)
  "join_game" -> process_join_game (seqid,iprot,oprot,handler)
  "take_action" -> process_take_action (seqid,iprot,oprot,handler)
  "public_message" -> process_public_message (seqid,iprot,oprot,handler)
  "group_message" -> process_group_message (seqid,iprot,oprot,handler)
  "private_message" -> process_private_message (seqid,iprot,oprot,handler)
  _ -> do
    _ <- T.readVal iprot (T.T_STRUCT Map.empty)
    T.writeMessageBegin oprot (name,T.M_EXCEPTION,seqid)
    T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN_METHOD ("Unknown function " ++ LT.unpack name))
    T.writeMessageEnd oprot
    T.tFlush (T.getTransport oprot)
process handler (iprot, oprot) = do
  (name, typ, seqid) <- T.readMessageBegin iprot
  proc_ handler (iprot,oprot) (name,typ,seqid)
  T.readMessageEnd iprot
  P.return P.True
