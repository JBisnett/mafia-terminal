{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.9.3)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module MafiaServer_Client(ping,join_game,take_action,public_message,group_message,private_message) where
import qualified Data.IORef as R
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T


import Mafia_Types
import MafiaServer
seqid = R.newIORef 0
ping (ip,op) = do
  send_ping op
  recv_ping ip
send_ping op = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("ping", T.M_CALL, seqn)
  write_Ping_args op (Ping_args{})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_ping ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_Ping_result ip
  T.readMessageEnd ip
  P.return ()
join_game (ip,op) arg_name arg_host = do
  send_join_game op arg_name arg_host
  recv_join_game ip
send_join_game op arg_name arg_host = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("join_game", T.M_CALL, seqn)
  write_Join_game_args op (Join_game_args{join_game_args_name=arg_name,join_game_args_host=arg_host})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_join_game ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_Join_game_result ip
  T.readMessageEnd ip
  P.return $ join_game_result_success res
take_action (ip,op) arg_action arg_target = do
  send_take_action op arg_action arg_target
  recv_take_action ip
send_take_action op arg_action arg_target = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("take_action", T.M_CALL, seqn)
  write_Take_action_args op (Take_action_args{take_action_args_action=arg_action,take_action_args_target=arg_target})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_take_action ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_Take_action_result ip
  T.readMessageEnd ip
  P.return $ take_action_result_success res
public_message (ip,op) arg_message = do
  send_public_message op arg_message
  recv_public_message ip
send_public_message op arg_message = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("public_message", T.M_CALL, seqn)
  write_Public_message_args op (Public_message_args{public_message_args_message=arg_message})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_public_message ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_Public_message_result ip
  T.readMessageEnd ip
  P.return $ public_message_result_success res
group_message (ip,op) arg_group_id arg_message = do
  send_group_message op arg_group_id arg_message
  recv_group_message ip
send_group_message op arg_group_id arg_message = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("group_message", T.M_CALL, seqn)
  write_Group_message_args op (Group_message_args{group_message_args_group_id=arg_group_id,group_message_args_message=arg_message})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_group_message ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_Group_message_result ip
  T.readMessageEnd ip
  P.return $ group_message_result_success res
private_message (ip,op) arg_player_name arg_message = do
  send_private_message op arg_player_name arg_message
  recv_private_message ip
send_private_message op arg_player_name arg_message = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("private_message", T.M_CALL, seqn)
  write_Private_message_args op (Private_message_args{private_message_args_player_name=arg_player_name,private_message_args_message=arg_message})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_private_message ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_Private_message_result ip
  T.readMessageEnd ip
  P.return $ private_message_result_success res
